name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  unit-tests:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    
    env:
      NODE_ENV: test
      DB_DIALECT: sqlite
      DB_STORAGE: ./unit-test-db.sqlite
      JWT_SECRET: test-jwt-unit-$(date +%s)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: |
        npm ci
        echo "‚úÖ Dependencies installed"

    - name: Create test database
      run: |
        touch $DB_STORAGE
        echo "üìÅ Database file: $DB_STORAGE"

    - name: Run unit tests
      run: |
        echo "üß™ Running unit tests..."
        npm test -- --verbose
      continue-on-error: false

  stage:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: unit-tests
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Debug current commit
      run: |
        echo "üìå Current commit hash: $(git rev-parse HEAD)"
        echo "üìå Commit message: $(git log -1 --pretty=%B)"
        echo "üìå Code in server.js:"
        grep -A2 -B2 'app.get("/"' server.js || echo "Route not found in server.js"

    - name: Deploy specific commit to Staging
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        RENDER_STAGING_SERVICE_ID: ${{ secrets.RENDER_STAGING_SERVICE_ID }}
        GITHUB_SHA: ${{ github.sha }}
      run: |
        echo "üöÄ Deploying commit $GITHUB_SHA to Staging..."
        
        # 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–ø–ª–æ–π
        echo "üìã Checking current deploy status..."
        CURRENT_DEPLOY=$(curl -s \
          "https://api.render.com/v1/services/$RENDER_STAGING_SERVICE_ID" \
          -H "Authorization: Bearer $RENDER_API_KEY")
        
        echo "Current service: $CURRENT_DEPLOY"
        
        # 2. –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –¥–µ–ø–ª–æ–π
        echo "üîÑ Starting new deployment..."
        DEPLOY_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          "https://api.render.com/v1/services/$RENDER_STAGING_SERVICE_ID/deploys" \
          -H "Authorization: Bearer $RENDER_API_KEY" \
          -H "Content-Type: application/json" \
          -d '{
            "clearCache": true
          }')
        
        # –†–∞–∑–¥–µ–ª—è–µ–º –æ—Ç–≤–µ—Ç –∏ —Å—Ç–∞—Ç—É—Å –∫–æ–¥
        DEPLOY_BODY=$(echo "$DEPLOY_RESPONSE" | head -n -1)
        DEPLOY_STATUS=$(echo "$DEPLOY_RESPONSE" | tail -n1)
        
        echo "Deploy response status: $DEPLOY_STATUS"
        echo "Deploy response body: $DEPLOY_BODY"
        
        if [ "$DEPLOY_STATUS" = "200" ] || [ "$DEPLOY_STATUS" = "201" ]; then
          echo "‚úÖ Staging deployment triggered successfully!"
          
          # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –¥–µ–ø–ª–æ—è
          DEPLOY_ID=$(echo "$DEPLOY_BODY" | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)
          echo "Deploy ID: $DEPLOY_ID"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –¥–µ–ø–ª–æ—è
          echo "‚è≥ Checking deploy status..."
          sleep 10
          
          CHECK_COUNTER=0
          MAX_CHECKS=30
          
          while [ $CHECK_COUNTER -lt $MAX_CHECKS ]; do
            DEPLOY_INFO=$(curl -s \
              "https://api.render.com/v1/services/$RENDER_STAGING_SERVICE_ID/deploys/$DEPLOY_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY")
            
            STATUS=$(echo "$DEPLOY_INFO" | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "Deploy status: $STATUS (check $((CHECK_COUNTER + 1))/$MAX_CHECKS)"
            
            if [ "$STATUS" = "succeeded" ]; then
              echo "üéâ Deploy succeeded!"
              break
            elif [ "$STATUS" = "failed" ] || [ "$STATUS" = "canceled" ]; then
              echo "‚ùå Deploy failed: $STATUS"
              echo "Deploy info: $DEPLOY_INFO"
              exit 1
            fi
            
            sleep 10
            CHECK_COUNTER=$((CHECK_COUNTER + 1))
          done
          
          if [ $CHECK_COUNTER -eq $MAX_CHECKS ]; then
            echo "‚ö†Ô∏è Deploy still in progress after $MAX_CHECKS checks"
          fi
          
        else
          echo "‚ùå Failed to trigger deploy: HTTP $DEPLOY_STATUS"
          echo "Response: $DEPLOY_BODY"
          exit 1
        fi

    - name: Wait for application to start
      run: |
        echo "‚è≥ Waiting 90 seconds for application to fully start..."
        sleep 90

  integration-tests:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    needs: stage
    
    env:
      NODE_ENV: test
      DB_DIALECT: sqlite
      DB_STORAGE: ./integration-test-db.sqlite
      JWT_SECRET: test-jwt-integration-$(date +%s)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: npm ci

    - name: Create test database
      run: |
        touch $DB_STORAGE
        echo "üìÅ Database file: $DB_STORAGE"

    - name: Run integration tests
      run: |
        echo "üß™ Running integration tests..."
        echo "Using SQLite database: $DB_STORAGE"
        npm run test:integration -- --verbose --detectOpenHandles
      continue-on-error: false

    - name: Verify Staging Deployment
      env:
        STAGING_URL: ${{ secrets.RENDER_STAGING_URL }}
      run: |
        echo "üß™ Verifying Staging Deployment..."
        echo "Staging URL: $STAGING_URL"
        
        counter=0
        max_attempts=20
        
        while [ $counter -lt $max_attempts ]; do
          echo "‚è≥ Attempt $((counter + 1))/$max_attempts"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º health endpoint
          health_response=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$STAGING_URL/health" || echo "000")
          
          if [ "$health_response" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $health_response)"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π endpoint
            content=$(curl -s --max-time 10 "$STAGING_URL/" || echo "CURL_ERROR")
            
            if echo "$content" | grep -q "11111111fghjkl;1"; then
              echo "üéâ SUCCESS! New code deployed to staging!"
              echo "Response: $content"
              exit 0
            elif echo "$content" | grep -q "111111111"; then
              echo "‚ùå OLD CODE DETECTED! Staging still has old message"
              echo "Response: $content"
              exit 1
            else
              echo "‚ö†Ô∏è Unexpected response: $content"
              exit 1
            fi
          else
            echo "‚ùå Health check failed (HTTP $health_response), waiting 10 seconds..."
            sleep 10
            counter=$((counter + 1))
          fi
        done
        
        echo "‚ö†Ô∏è Staging verification failed after $max_attempts attempts"
        exit 1

  deploy-production:
    name: Deploy to Production (Auto CI/CD)
    runs-on: ubuntu-latest
    needs: integration-tests
    environment: production
    if: success()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Debug production commit
      run: |
        echo "üìå Deploying to production commit: $(git rev-parse HEAD)"
        echo "üìå Code to deploy:"
        grep -A2 -B2 'app.get("/"' server.js

    - name: Deploy to Production
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        RENDER_PRODUCTION_SERVICE_ID: ${{ secrets.RENDER_PRODUCTION_SERVICE_ID }}
      run: |
        echo "üöÄ Deploying to Production..."
        
        DEPLOY_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          "https://api.render.com/v1/services/$RENDER_PRODUCTION_SERVICE_ID/deploys" \
          -H "Authorization: Bearer $RENDER_API_KEY" \
          -H "Content-Type: application/json" \
          -d '{"clearCache": true}')
        
        DEPLOY_BODY=$(echo "$DEPLOY_RESPONSE" | head -n -1)
        DEPLOY_STATUS=$(echo "$DEPLOY_RESPONSE" | tail -n1)
        
        if [ "$DEPLOY_STATUS" = "200" ] || [ "$DEPLOY_STATUS" = "201" ]; then
          echo "‚úÖ Production deployment triggered!"
          echo "Response: $DEPLOY_BODY"
        else
          echo "‚ùå Failed to trigger production deploy: HTTP $DEPLOY_STATUS"
          echo "Response: $DEPLOY_BODY"
          exit 1
        fi

    - name: Wait for production deployment
      run: |
        echo "‚è≥ Waiting 120 seconds for production deployment..."
        sleep 120

    - name: Verify Production Deployment
      env:
        PRODUCTION_URL: ${{ secrets.RENDER_PRODUCTION_URL }}
      run: |
        echo "üß™ Verifying Production Deployment..."
        echo "Production URL: $PRODUCTION_URL"
        
        counter=0
        max_attempts=25
        
        while [ $counter -lt $max_attempts ]; do
          echo "‚è≥ Attempt $((counter + 1))/$max_attempts"
          
          health_response=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$PRODUCTION_URL/health" || echo "000")
          
          if [ "$health_response" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $health_response)"
            
            content=$(curl -s --max-time 10 "$PRODUCTION_URL/" || echo "CURL_ERROR")
            
            if echo "$content" | grep -q "11111111fghjkl;1"; then
              echo "üéâ SUCCESS! New code deployed to production!"
              echo "Response: $content"
              exit 0
            else
              echo "‚ö†Ô∏è Unexpected production response: $content"
              exit 1
            fi
          else
            echo "‚ùå Health check failed (HTTP $health_response), waiting 15 seconds..."
            sleep 15
            counter=$((counter + 1))
          fi
        done
        
        echo "‚ö†Ô∏è Production verification failed after $max_attempts attempts"
        exit 1