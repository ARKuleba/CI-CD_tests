name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  unit-tests:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    
    env:
      NODE_ENV: test
      DB_DIALECT: sqlite
      DB_STORAGE: ./unit-test-db.sqlite
      JWT_SECRET: test-jwt-unit-$(date +%s)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: |
        npm ci
        echo "‚úÖ Dependencies installed"

    - name: Create test database
      run: |
        touch $DB_STORAGE
        echo "üìÅ Database file: $DB_STORAGE"

    - name: Run unit tests
      run: |
        echo "üß™ Running unit tests..."
        npm test -- --verbose
      continue-on-error: false

  stage:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: unit-tests
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Debug current commit
      run: |
        echo "üìå Current commit hash: $(git rev-parse HEAD)"
        echo "üìå Commit message: $(git log -1 --pretty=%B)"

    - name: Deploy to Staging via Render Hook
      env:
        RENDER_STAGING_DEPLOY_HOOK: ${{ secrets.RENDER_STAGING_DEPLOY_HOOK }}
      run: |
        echo "üöÄ Deploying to Staging via Render Hook..."
        echo "Hook URL (first 60 chars): ${RENDER_STAGING_DEPLOY_HOOK:0:60}..."
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ Render Hook
        response=$(curl -s -w "%{http_code}" -X POST "$RENDER_STAGING_DEPLOY_HOOK")
        status_code=${response: -3}
        
        if [ "$status_code" = "200" ] || [ "$status_code" = "201" ]; then
          echo "‚úÖ Staging deployment triggered successfully (HTTP $status_code)"
          echo "Render will deploy commit: $(git rev-parse HEAD)"
        else
          echo "‚ùå Failed to trigger staging deploy: HTTP $status_code"
          exit 1
        fi

    - name: Wait for staging deployment
      run: |
        echo "‚è≥ Waiting 60 seconds for deployment to start..."
        sleep 60

  integration-tests:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    needs: stage
    
    env:
      NODE_ENV: test
      DB_DIALECT: sqlite
      DB_STORAGE: ./integration-test-db.sqlite
      JWT_SECRET: test-jwt-integration-$(date +%s)

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: npm ci

    - name: Create test database
      run: |
        touch $DB_STORAGE
        echo "üìÅ Database file: $DB_STORAGE"

    - name: Run integration tests
      run: |
        echo "üß™ Running integration tests..."
        echo "Using SQLite database: $DB_STORAGE"
        npm run test:integration -- --verbose --detectOpenHandles
      continue-on-error: false

    - name: Smoke test Staging
      if: success()
      env:
        STAGING_URL: ${{ secrets.RENDER_STAGING_URL }}
      run: |
        echo "üß™ Testing Staging Environment..."
        echo "Staging URL: $STAGING_URL"
        
        counter=0
        max_attempts=15
        
        while [ $counter -lt $max_attempts ]; do
          response=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$STAGING_URL/health" || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Staging is up and running (HTTP $response)"
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
            content=$(curl -s "$STAGING_URL/")
            echo "üìÑ Staging response: $content"
            exit 0
          else
            echo "‚è≥ Attempt $((counter + 1))/$max_attempts - Health check failed (HTTP $response)"
            sleep 10
            counter=$((counter + 1))
          fi
        done
        
        echo "‚ö†Ô∏è Staging failed to start after $max_attempts attempts"
        exit 1

  deploy-production:
    name: Deploy to Production (Auto CI/CD)
    runs-on: ubuntu-latest
    needs: integration-tests
    environment: production
    if: success()  # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω—ã—Ö —Ç–µ—Å—Ç–∞—Ö

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Debug production commit
      run: |
        echo "üìå Deploying to production commit: $(git rev-parse HEAD)"
        echo "üìå Commit message: $(git log -1 --pretty=%B)"

    - name: Deploy to Production via Render Hook
      env:
        RENDER_PRODUCTION_DEPLOY_HOOK: ${{ secrets.RENDER_PRODUCTION_DEPLOY_HOOK }}
      run: |
        echo "üöÄ Deploying to Production via Render Hook..."
        echo "Hook URL (first 60 chars): ${RENDER_PRODUCTION_DEPLOY_HOOK:0:60}..."
        
        response=$(curl -s -w "%{http_code}" -X POST "$RENDER_PRODUCTION_DEPLOY_HOOK")
        status_code=${response: -3}
        
        if [ "$status_code" = "200" ] || [ "$status_code" = "201" ]; then
          echo "‚úÖ Production deployment triggered successfully (HTTP $status_code)"
          echo "Production will deploy commit: $(git rev-parse HEAD)"
        else
          echo "‚ùå Failed to trigger production deploy: HTTP $status_code"
          exit 1
        fi

    - name: Wait for production deployment
      run: |
        echo "‚è≥ Waiting 90 seconds for production deployment..."
        sleep 90

    - name: Smoke test Production
      if: success()
      env:
        PRODUCTION_URL: ${{ secrets.RENDER_PRODUCTION_URL }}
      run: |
        echo "üß™ Testing Production Environment..."
        echo "Production URL: $PRODUCTION_URL"
        
        counter=0
        max_attempts=20
        
        while [ $counter -lt $max_attempts ]; do
          response=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$PRODUCTION_URL/health" || echo "000")
          
          if [ "$response" = "200" ]; then
            echo "‚úÖ Production is up and running (HTTP $response)"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω–∏–ª–∏—Å—å
            content=$(curl -s "$PRODUCTION_URL/")
            echo "üìÑ Production response: $content"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –∏–º–µ–Ω–Ω–æ –Ω–∞—à–µ –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            if echo "$content" | grep -q "11111111fghjkl;1"; then
              echo "üéâ SUCCESS! New changes deployed to production!"
            else
              echo "‚ö†Ô∏è Production is running, but content may be old"
            fi
            exit 0
          else
            echo "‚è≥ Attempt $((counter + 1))/$max_attempts - Health check failed (HTTP $response)"
            sleep 15
            counter=$((counter + 1))
          fi
        done
        
        echo "‚ö†Ô∏è Production failed to start after $max_attempts attempts"
        exit 1